from fastapi import APIRouter, Depends, HTTPException
from elastic import es
from models import Favorite
from auth import verify_token
from typing import List

user_router = APIRouter(prefix="/user", tags=["User Endpoints"])


# ===============================================================
# ðŸ”¹ FETCH ALL SONGS (Public)
# ===============================================================
@user_router.get("/songs")
def get_songs():
    """
    Fetch all songs stored in the Elasticsearch `songs` index.
    This is a public endpointâ€”no login required.

    Returns:
        List of song documents (up to 500).
    """
    res = es.search(
        index="songs",
        body={"query": {"match_all": {}}},
        size=500
    )
    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”¹ FETCH ALL ALBUMS (Public)
# ===============================================================
@user_router.get("/albums")
def get_albums():
    """
    Fetch all albums from the `albums` index.
    Useful for populating the Album dropdown in the Admin panel.
    """
    res = es.search(
        index="albums",
        body={"query": {"match_all": {}}},
        size=500
    )
    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”¹ FETCH ALL ARTISTS (Public)
# ===============================================================
@user_router.get("/artists")
def get_artists():
    """
    Fetch all artists from the `artists` index.
    Used by Search, Dashboard, and Admin Add Song screens.
    """
    res = es.search(
        index="artists",
        body={"query": {"match_all": {}}},
        size=500
    )
    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”¹ FETCH ALERTS (Public)
# ===============================================================
@user_router.get("/alerts")
def get_alerts():
    """
    Alerts are generated by trigger jobs (APScheduler).
    This endpoint retrieves latest system events (new songs, top artists, etc.)
    sorted by timestamp (newest first).
    """
    res = es.search(
        index="alerts",
        body={
            "sort": [{"timestamp": {"order": "desc"}}],
            "query": {"match_all": {}}
        },
        size=50
    )

    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”’ ADD FAVORITE (Requires Firebase Auth)
# ===============================================================
@user_router.post("/favorite")
async def add_favorite(
    fav: Favorite,
    decoded=Depends(verify_token)
):
    """
    Add a favorite song/artist/genre for the logged-in user.
    Firebase Authentication is used to verify the JWT token.

    Steps:
    - Extract the user's Firebase UID
    - Attach UID to the favorite document
    - Store in Elasticsearch in the `favorites` index

    Returns:
        Confirmation message
    """
    fav.user_id = decoded["uid"]

    es.index(index="favorites", document=fav.dict())
    return {"message": "Favorite added successfully!", "favorite": fav}


# ===============================================================
# ðŸ”’ GET LOGGED-IN USER FAVORITES
# ===============================================================
@user_router.get("/favorites")
async def get_user_favorites(decoded=Depends(verify_token)):
    """
    Retrieve all favorites for the authenticated user.

    Backend automatically:
    - Extracts Firebase UID from JWT
    - Queries Elasticsearch for matching favorites
    """
    user_id = decoded["uid"]

    res = es.search(
        index="favorites",
        body={"query": {"term": {"user_id": user_id}}},
        size=200
    )
    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”’ REMOVE FAVORITE ITEM
# ===============================================================
@user_router.delete("/favorite")
async def remove_favorite(
    item_type: str,
    item_value: str,
    decoded=Depends(verify_token)
):
    """
    Remove a favorite entry by specifying:
    - item_type: 'song', 'artist', 'album'
    - item_value: track_id or artist_id or album_id

    Removes only the authenticated user's document.
    """
    user_id = decoded["uid"]

    query = {
        "query": {
            "bool": {
                "must": [
                    {"term": {"user_id": user_id}},
                    {"term": {"item_type": item_type}},
                    {"term": {"item_value": item_value}}
                ]
            }
        }
    }

    es.delete_by_query(index="favorites", body=query)

    return {"message": "Favorite removed successfully!"}


# ===============================================================
# ðŸ”¹ SEARCH SONGS (Public)
# ===============================================================
@user_router.get("/search")
def search_songs(q: str):
    """
    Full-text search across multiple fields using Elasticsearch Multi-Match Query.

    Fields searched:
    - track_name (weighted highest)
    - artists
    - album_name
    - track_genre

    Returns a ranked list of results.
    """
    res = es.search(
        index="songs",
        body={
            "query": {
                "multi_match": {
                    "query": q,
                    "fields": [
                        "track_name^3",
                        "artists",
                        "album_name",
                        "track_genre"
                    ]
                }
            }
        },
        size=200
    )
    return [hit["_source"] for hit in res["hits"]["hits"]]


# ===============================================================
# ðŸ”¹ AUTOCOMPLETE (Public)
# ===============================================================
@user_router.get("/autocomplete")
def autocomplete(q: str):
    """
    Autocomplete suggestions using the edge_ngram analyzer.

    User types:
    â†’ "bl"
    â†’ suggestions returned: ["Blinding Lights", "Bluebird", "Bloom"]

    This is extremely fast because Elasticsearch expands prefixes automatically.
    """
    res = es.search(
        index="songs",
        body={
            "query": {
                "match_phrase_prefix": {
                    "track_name": q
                }
            }
        },
        size=10
    )

    return [hit["_source"]["track_name"] for hit in res["hits"]["hits"]]
